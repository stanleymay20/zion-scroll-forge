/**
 * ProjectService - Core project lifecycle management for ScrollProjectsSpec
 * Handles project creation, status updates, and lifecycle orchestration
 */

import { v4 as uuidv4 } from 'uuid';
import {
  ScrollProjectSpec,
  MilestoneSpec,
  CreateProjectRequest,
  ProjectCreationResponse,
  ProjectStatus,
  MilestoneStage,
  ScrollField,
  ValidationResult,
  MentorProfile,
  ProjectMetadata,
  IntegritySeal
} from '../types/scroll-projects.js';
import { ValidationService } from './ValidationService.js';
import { MentorService } from './MentorService.js';
import { HookService } from './HookService.js';

export class ProjectService {
  private validationService: ValidationService;
  private mentorService: MentorService;
  private hookService: HookService;

  constructor(
    validationService: ValidationService,
    mentorService: MentorService,
    hookService: HookService
  ) {
    this.validationService = validationService;
    this.mentorService = mentorService;
    this.hookService = hookService;
  }

  /**
   * Creates a new project with initial milestone structure
   */
  async createProject(studentId: string, projectData: CreateProjectRequest): Promise<ProjectCreationResponse> {
    try {
      // Validate the creation request
      const validationResult = await this.validationService.validateCreateProjectRequest(projectData);
      if (!validationResult.valid) {
        return {
          project: {} as ScrollProjectSpec,
          assigned_mentor: {} as MentorProfile,
          initial_milestones: [],
          success: false,
          message: `Validation failed: ${validationResult.errors.map(e => e.message).join(', ')}`
        };
      }

      // Generate project ID and timestamps
      const projectId = uuidv4();
      const now = new Date();

      // Assign mentor based on scroll field
      const assignedMentor = await this.mentorService.assignMentor(projectData.scroll_field, studentId);

      // Create initial milestone structure
      const initialMilestones = this.createInitialMilestones(projectId);

      // Build project metadata
      const metadata: ProjectMetadata = {
        tags: projectData.tags || [],
        difficulty_level: this.determineDifficultyLevel(projectData),
        estimated_duration_weeks: projectData.estimated_duration_weeks || 12,
        real_world_impact_score: 0, // Will be calculated as project progresses
        collaboration_allowed: projectData.collaboration_allowed || false,
        public_visibility: false, // Default to private until published
        marketplace_category: this.determineMarketplaceCategory(projectData.scroll_field)
      };

      // Create the project object
      const project: ScrollProjectSpec = {
        project_id: projectId,
        student_id: studentId,
        title: projectData.title,
        description: projectData.description,
        scroll_field: projectData.scroll_field,
        mentor_id: assignedMentor.mentor_id,
        status: ProjectStatus.PROPOSAL,
        milestones: initialMilestones,
        gpt_summary: '', // Will be generated by GPT service
        scrollcoin_earned: 0,
        published: false,
        created_at: now,
        updated_at: now,
        metadata
      };

      // Validate the complete project
      const projectValidation = await this.validationService.validateProject(project);
      if (!projectValidation.valid) {
        return {
          project: {} as ScrollProjectSpec,
          assigned_mentor: {} as MentorProfile,
          initial_milestones: [],
          success: false,
          message: `Project validation failed: ${projectValidation.errors.map(e => e.message).join(', ')}`
        };
      }

      // Save project to database (placeholder - would integrate with actual DB)
      await this.saveProject(project);

      // Trigger onProjectCreate hook
      await this.hookService.executeHook('onProjectCreate', {
        event_id: uuidv4(),
        event_type: 'project_created',
        project_id: projectId,
        student_id: studentId,
        timestamp: now,
        payload: { project, mentor: assignedMentor },
        source: 'ProjectService'
      });

      return {
        project,
        assigned_mentor: assignedMentor,
        initial_milestones: initialMilestones,
        success: true,
        message: 'Project created successfully'
      };

    } catch (error) {
      return {
        project: {} as ScrollProjectSpec,
        assigned_mentor: {} as MentorProfile,
        initial_milestones: [],
        success: false,
        message: `Project creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Updates project status with validation
   */
  async updateProjectStatus(projectId: string, newStatus: ProjectStatus, updatedBy: string): Promise<ValidationResult> {
    try {
      const project = await this.getProject(projectId);
      if (!project) {
        return {
          valid: false,
          errors: [{
            field: 'project_id',
            message: 'Project not found',
            error_code: 'PROJECT_NOT_FOUND',
            severity: 'critical'
          }],
          warnings: [],
          scroll_alignment_score: 0
        };
      }

      // Validate status transition
      const transitionValidation = this.validationService.validateStatusTransition(project.status, newStatus);
      if (!transitionValidation.valid) {
        return transitionValidation;
      }

      // Check prerequisites for specific status changes
      const prerequisiteValidation = await this.validateStatusPrerequisites(project, newStatus);
      if (!prerequisiteValidation.valid) {
        return prerequisiteValidation;
      }

      // Update project status
      const updatedProject = {
        ...project,
        status: newStatus,
        updated_at: new Date()
      };

      // Apply integrity seal if moving to LISTED status
      if (newStatus === ProjectStatus.LISTED) {
        updatedProject.integrity_seal = await this.applyIntegritySeal(projectId, updatedBy);
        updatedProject.published = true;
      }

      // Save updated project
      await this.saveProject(updatedProject);

      // Trigger status change hook
      await this.hookService.executeHook('onStatusChange', {
        event_id: uuidv4(),
        event_type: 'status_changed',
        project_id: projectId,
        student_id: project.student_id,
        timestamp: new Date(),
        payload: { 
          old_status: project.status, 
          new_status: newStatus,
          updated_by: updatedBy
        },
        source: 'ProjectService'
      });

      return {
        valid: true,
        errors: [],
        warnings: transitionValidation.warnings,
        scroll_alignment_score: 100
      };

    } catch (error) {
      return {
        valid: false,
        errors: [{
          field: 'status',
          message: `Status update failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
          error_code: 'STATUS_UPDATE_ERROR',
          severity: 'critical'
        }],
        warnings: [],
        scroll_alignment_score: 0
      };
    }
  }

  /**
   * Retrieves a project by ID
   */
  async getProject(projectId: string): Promise<ScrollProjectSpec | null> {
    try {
      // Placeholder implementation - would integrate with actual database
      return await this.loadProject(projectId);
    } catch (error) {
      console.error(`Failed to retrieve project ${projectId}:`, error);
      return null;
    }
  }

  /**
   * Retrieves all projects for a student
   */
  async getStudentProjects(studentId: string): Promise<ScrollProjectSpec[]> {
    try {
      // Placeholder implementation - would integrate with actual database
      return await this.loadStudentProjects(studentId);
    } catch (error) {
      console.error(`Failed to retrieve projects for student ${studentId}:`, error);
      return [];
    }
  }

  /**
   * Validates scroll alignment for a project
   */
  async validateScrollAlignment(project: ScrollProjectSpec): Promise<ValidationResult> {
    return await this.validationService.validateProject(project);
  }

  /**
   * Updates project metadata
   */
  async updateProjectMetadata(projectId: string, metadata: Partial<ProjectMetadata>): Promise<boolean> {
    try {
      const project = await this.getProject(projectId);
      if (!project) {
        return false;
      }

      const updatedProject = {
        ...project,
        metadata: { ...project.metadata, ...metadata },
        updated_at: new Date()
      };

      await this.saveProject(updatedProject);
      return true;
    } catch (error) {
      console.error(`Failed to update metadata for project ${projectId}:`, error);
      return false;
    }
  }

  /**
   * Calculates project completion percentage
   */
  calculateProjectCompletion(project: ScrollProjectSpec): number {
    const completedMilestones = project.milestones.filter(m => m.completed).length;
    return (completedMilestones / project.milestones.length) * 100;
  }

  /**
   * Gets project statistics
   */
  async getProjectStatistics(projectId: string): Promise<{
    completion_percentage: number;
    days_active: number;
    milestones_completed: number;
    total_milestones: number;
    scroll_alignment_score: number;
  }> {
    const project = await this.getProject(projectId);
    if (!project) {
      throw new Error('Project not found');
    }

    const validationResult = await this.validateScrollAlignment(project);
    const daysActive = Math.floor((new Date().getTime() - project.created_at.getTime()) / (1000 * 60 * 60 * 24));

    return {
      completion_percentage: this.calculateProjectCompletion(project),
      days_active: daysActive,
      milestones_completed: project.milestones.filter(m => m.completed).length,
      total_milestones: project.milestones.length,
      scroll_alignment_score: validationResult.scroll_alignment_score
    };
  }

  /**
   * Private helper methods
   */
  private createInitialMilestones(projectId: string): MilestoneSpec[] {
    const stages = [
      {
        stage: MilestoneStage.PROPOSAL,
        title: 'Project Proposal',
        description: 'Define project scope, objectives, and initial design',
        deliverables: ['Project proposal document', 'Initial research summary', 'Success criteria definition']
      },
      {
        stage: MilestoneStage.PROTOTYPE,
        title: 'Prototype Development',
        description: 'Build working prototype or proof of concept',
        deliverables: ['Working prototype', 'Technical documentation', 'User feedback collection']
      },
      {
        stage: MilestoneStage.TESTING,
        title: 'Testing and Validation',
        description: 'Test solution with real users and gather feedback',
        deliverables: ['Test results report', 'User feedback analysis', 'Iteration plan']
      },
      {
        stage: MilestoneStage.FINAL,
        title: 'Final Implementation',
        description: 'Complete final version ready for publication',
        deliverables: ['Final solution', 'Complete documentation', 'Impact assessment report']
      }
    ];

    return stages.map(stageData => ({
      milestone_id: uuidv4(),
      project_id: projectId,
      stage: stageData.stage,
      title: stageData.title,
      description: stageData.description,
      completed: false,
      feedback: [],
      required_deliverables: stageData.deliverables,
      validation_criteria: this.createValidationCriteria(stageData.stage),
      completion_percentage: 0
    }));
  }

  private createValidationCriteria(stage: MilestoneStage): any[] {
    const baseCriteria = [
      {
        criteria_id: uuidv4(),
        name: 'Scroll Alignment',
        description: 'Project demonstrates alignment with scroll principles',
        required: true,
        validation_method: 'hybrid' as const,
        scroll_alignment_weight: 10,
        met: false
      },
      {
        criteria_id: uuidv4(),
        name: 'Quality Standards',
        description: 'Deliverables meet ScrollUniversity quality standards',
        required: true,
        validation_method: 'manual' as const,
        scroll_alignment_weight: 8,
        met: false
      }
    ];

    // Add stage-specific criteria
    const stageCriteria: Record<MilestoneStage, any[]> = {
      [MilestoneStage.PROPOSAL]: [
        {
          criteria_id: uuidv4(),
          name: 'Clear Objectives',
          description: 'Project objectives are clearly defined and measurable',
          required: true,
          validation_method: 'manual' as const,
          scroll_alignment_weight: 9,
          met: false
        }
      ],
      [MilestoneStage.PROTOTYPE]: [
        {
          criteria_id: uuidv4(),
          name: 'Functional Prototype',
          description: 'Prototype demonstrates core functionality',
          required: true,
          validation_method: 'automated' as const,
          scroll_alignment_weight: 7,
          met: false
        }
      ],
      [MilestoneStage.TESTING]: [
        {
          criteria_id: uuidv4(),
          name: 'User Validation',
          description: 'Solution has been tested with real users',
          required: true,
          validation_method: 'manual' as const,
          scroll_alignment_weight: 8,
          met: false
        }
      ],
      [MilestoneStage.FINAL]: [
        {
          criteria_id: uuidv4(),
          name: 'Production Ready',
          description: 'Solution is ready for production deployment',
          required: true,
          validation_method: 'hybrid' as const,
          scroll_alignment_weight: 9,
          met: false
        }
      ]
    };

    return [...baseCriteria, ...stageCriteria[stage]];
  }

  private determineDifficultyLevel(projectData: CreateProjectRequest): 'beginner' | 'intermediate' | 'advanced' {
    const complexityIndicators = [
      projectData.description.length > 1000,
      projectData.estimated_duration_weeks && projectData.estimated_duration_weeks > 16,
      projectData.collaboration_allowed,
      projectData.tags && projectData.tags.length > 5
    ];

    const complexityScore = complexityIndicators.filter(Boolean).length;

    if (complexityScore >= 3) return 'advanced';
    if (complexityScore >= 2) return 'intermediate';
    return 'beginner';
  }

  private determineMarketplaceCategory(scrollField: ScrollField): string {
    const categoryMap: Record<ScrollField, string> = {
      [ScrollField.SCROLL_MEDICINE]: 'healthcare',
      [ScrollField.SCROLL_AI]: 'technology',
      [ScrollField.SCROLL_GOVERNANCE]: 'governance',
      [ScrollField.SCROLL_ECONOMY]: 'finance',
      [ScrollField.SCROLL_THEOLOGY]: 'education',
      [ScrollField.SCROLL_LAW]: 'governance',
      [ScrollField.SCROLL_ENGINEERING]: 'technology',
      [ScrollField.SCROLL_ARTS]: 'arts',
      [ScrollField.SCROLL_HEALTH]: 'healthcare',
      [ScrollField.SCROLL_EDUCATION]: 'education'
    };

    return categoryMap[scrollField] || 'social_impact';
  }

  private async validateStatusPrerequisites(project: ScrollProjectSpec, newStatus: ProjectStatus): Promise<ValidationResult> {
    const errors: any[] = [];

    switch (newStatus) {
      case ProjectStatus.IN_PROGRESS:
        // Proposal milestone must be completed
        const proposalMilestone = project.milestones.find(m => m.stage === MilestoneStage.PROPOSAL);
        if (!proposalMilestone?.completed) {
          errors.push({
            field: 'status',
            message: 'Proposal milestone must be completed before moving to IN_PROGRESS',
            error_code: 'PROPOSAL_NOT_COMPLETED',
            severity: 'critical'
          });
        }
        break;

      case ProjectStatus.REVIEW:
        // All milestones except final must be completed
        const nonFinalMilestones = project.milestones.filter(m => m.stage !== MilestoneStage.FINAL);
        const incompleteNonFinal = nonFinalMilestones.filter(m => !m.completed);
        if (incompleteNonFinal.length > 0) {
          errors.push({
            field: 'status',
            message: 'All milestones except final must be completed before review',
            error_code: 'MILESTONES_INCOMPLETE',
            severity: 'critical'
          });
        }
        break;

      case ProjectStatus.SUBMITTED:
        // All milestones must be completed
        const incompleteMilestones = project.milestones.filter(m => !m.completed);
        if (incompleteMilestones.length > 0) {
          errors.push({
            field: 'status',
            message: 'All milestones must be completed before submission',
            error_code: 'ALL_MILESTONES_INCOMPLETE',
            severity: 'critical'
          });
        }
        break;

      case ProjectStatus.LISTED:
        // Project must have high scroll alignment score
        const alignmentResult = await this.validationService.validateProject(project);
        if (alignmentResult.scroll_alignment_score < 80) {
          errors.push({
            field: 'status',
            message: 'Project must have scroll alignment score of at least 80 for marketplace listing',
            error_code: 'INSUFFICIENT_SCROLL_ALIGNMENT',
            severity: 'critical'
          });
        }
        break;
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings: [],
      scroll_alignment_score: 100
    };
  }

  private async applyIntegritySeal(projectId: string, appliedBy: string): Promise<IntegritySeal> {
    return {
      seal_id: uuidv4(),
      applied_by: appliedBy,
      applied_at: new Date(),
      seal_type: 'scroll_oath',
      verification_hash: this.generateVerificationHash(projectId),
      expiry_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // 1 year from now
    };
  }

  private generateVerificationHash(projectId: string): string {
    // Placeholder implementation - would use proper cryptographic hashing
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(`${projectId}-${Date.now()}`).digest('hex');
  }

  // Database integration methods (placeholders)
  private async saveProject(project: ScrollProjectSpec): Promise<void> {
    // Placeholder - would integrate with actual database
    console.log(`Saving project ${project.project_id}`);
  }

  private async loadProject(projectId: string): Promise<ScrollProjectSpec | null> {
    // Placeholder - would integrate with actual database
    console.log(`Loading project ${projectId}`);
    return null;
  }

  private async loadStudentProjects(studentId: string): Promise<ScrollProjectSpec[]> {
    // Placeholder - would integrate with actual database
    console.log(`Loading projects for student ${studentId}`);
    return [];
  }
}